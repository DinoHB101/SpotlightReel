<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Spotlight Reel Creator</title>
  <style>
    body { font-family: system-ui, Arial; max-width: 1100px; margin: 24px auto; padding: 0 12px; }
    fieldset { margin: 16px 0; padding: 12px; border: 1px solid #ddd; border-radius: 10px; }
    legend { padding: 0 8px; }
    label { display:block; margin-top: 10px; font-weight: 600; }
    input, button, select { padding: 10px; margin-top: 6px; border-radius: 10px; border: 1px solid #ccc; }
    button { cursor: pointer; }
    .row { display:flex; gap: 12px; flex-wrap: wrap; align-items: flex-end; }
    .muted { color:#666; font-size: 13px; }
    .ok { color: #1b8a3a; font-weight: 700; }
    .bad { color: #b42318; font-weight: 700; }
    .hidden { display:none; }
    #log { white-space: pre-wrap; background:#0b1020; color:#e8ecff; padding: 12px; border-radius: 10px; min-height: 150px; }
    #avaturn-sdk-container { width: 100%; height: 650px; border-radius: 12px; overflow: hidden; border: 1px solid #ddd; }
    .pill { display:inline-block; padding: 4px 10px; border-radius: 999px; background:#f2f4f7; font-size: 12px; margin-left: 6px; }
    audio { width: 100%; margin-top: 10px; }
  </style>
</head>
<body>
  <h1>Spotlight Reel Creator</h1>
  <p class="muted">
    Flow: Login → Create avatar (Avaturn) → Record 5s voice (WAV) → Create/Update single UGC reel.
  </p>

  <fieldset>
    <legend>0) Config</legend>
    <div class="muted">These are public identifiers. Don’t put PlayFab Secret Key on this page.</div>
    <label>PlayFab TitleId</label>
    <input id="titleId" />

    <label>Avaturn subdomain</label>
    <input id="avaturnSubdomain" />

    <label>Animation Index</label>
    <select id="animIndex">
      <option value="0">Idle</option>
      <option value="1">Cheer</option>
      <option value="2">Wave</option>
      <option value="3">Dance</option>
    </select>

    <div class="row" style="margin-top: 12px;">
      <button id="btnUseDefaults" type="button">Use Defaults</button>
      <button id="btnClearSession" type="button">Clear Session</button>
      <span id="cfgStatus" class="muted"></span>
    </div>
  </fieldset>

  <fieldset id="loginBox">
    <legend>1) Login</legend>
    <div class="row">
      <div style="flex:1; min-width: 240px;">
        <label>Username</label>
        <input id="username" placeholder="Your PlayFab username" />
      </div>
      <div style="flex:1; min-width: 240px;">
        <label>Password</label>
        <input id="password" type="password" placeholder="Password" />
      </div>
      <div>
        <label>&nbsp;</label>
        <button id="btnLogin" type="button">Login</button>
      </div>
    </div>
    <div id="loginStatus" class="muted"></div>
  </fieldset>

  <fieldset id="avaturnBox" class="hidden">
    <legend>2) Create Avatar</legend>
    <div class="muted">
      Click Next/Export in Avaturn when done. We’ll capture the model URL.
      <span id="avaturnPill" class="pill">Waiting for export…</span>
    </div>
    <div id="avaturn-sdk-container"></div>
    <div class="muted" id="avaturnStatus"></div>
  </fieldset>

  <fieldset id="audioBox" class="hidden">
    <legend>3) Voice Note</legend>
    <div class="row">
      <button id="btnRec" type="button">Record 5s</button>
      <button id="btnStop" type="button" disabled>Stop</button>
      <span id="recStatus" class="muted"></span>
    </div>
    <audio id="audioPreview" controls class="hidden"></audio>
    <div class="muted">Tip: recording works only on https or localhost.</div>
  </fieldset>

  <fieldset id="submitBox" class="hidden">
    <legend>4) Create/Update Reel</legend>

    <label>Item Title</label>
    <input id="itemTitle" value="Spotlight Reel" />

    <div class="row" style="margin-top: 12px;">
      <button id="btnSubmit" type="button">Create / Update Reel</button>
      <span id="submitStatus" class="muted"></span>
    </div>

    <div class="muted" style="margin-top: 10px;">
      We store:
      <ul>
        <li>Voice file in UGC contents (WAV)</li>
        <li>Avaturn URL + animationIndex in item metadata</li>
        <li>PrimaryReelItemId in UserData</li>
      </ul>
    </div>
  </fieldset>

  <fieldset>
    <legend>Log</legend>
    <div id="log"></div>
  </fieldset>

  <script type="module">
    import { AvaturnSDK } from "https://cdn.jsdelivr.net/npm/@avaturn/sdk/dist/index.js";

    // -----------------------------
    // Defaults (edit these)
    // -----------------------------
    const DEFAULTS = {
      PLAYFAB_TITLE_ID: "1E3DA1",
      AVATURN_SUBDOMAIN: "msocial"
    };

    // -----------------------------
    // Tiny UI helpers
    // -----------------------------
    const $ = (id) => document.getElementById(id);
    const logEl = $("log");
    function log(msg, cls="") {
      const line = cls ? `[${cls.toUpperCase()}] ${msg}` : msg;
      logEl.textContent += line + "\n";
      logEl.scrollTop = logEl.scrollHeight;
    }
    function setText(id, text, cls="") {
      const el = $(id);
      el.className = cls ? cls : "";
      el.textContent = text;
    }
    function show(id) { $(id).classList.remove("hidden"); }
    function hide(id) { $(id).classList.add("hidden"); }

    // -----------------------------
    // State
    // -----------------------------
    let sessionTicket = null;
    let entityToken = null;
    let entity = null;          // {Id, Type}
    let avaturnModelUrl = null; // from Avaturn export
    let recordedAudioBlob = null;

    // -----------------------------
    // Storage keys
    // -----------------------------
    const SS = {
      titleId: "pf_titleId",
      avaturnSubdomain: "avaturn_subdomain",
      sessionTicket: "pf_sessionTicket",
      entityToken: "pf_entityToken",
      entity: "pf_entity"
    };

    // Player data key for 1-reel-per-user
    const PRIMARY_REEL_KEY = "PrimaryReelItemId";

    // -----------------------------
    // PlayFab HTTP
    // -----------------------------
    async function playfabPost(titleId, path, body, headers = {}) {
      const url = `https://${titleId}.playfabapi.com/${path}`;
      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json", ...headers },
        body: JSON.stringify(body)
      });
      const json = await res.json().catch(() => null);
      if (!res.ok || !json || json.error) {
        const errMsg = json?.errorMessage || json?.error || `HTTP ${res.status}`;
        throw new Error(`${path} failed: ${errMsg}`);
      }
      return json.data;
    }

    function getTitleId() {
      const v = $("titleId").value.trim();
      if (!v) throw new Error("TitleId is missing");
      return v;
    }

    // Azure blob PUT for PlayFab CreateUploadUrls
    async function putToAzureBlob(uploadUrlWithToken, blobOrFile) {
      const res = await fetch(uploadUrlWithToken, {
        method: "PUT",
        headers: {
          "x-ms-blob-type": "BlockBlob",
          "comp": "blob"
        },
        body: blobOrFile
      });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`Azure PUT failed: HTTP ${res.status} ${txt}`.trim());
      }
    }

    // -----------------------------
    // Token persistence (sessionStorage)
    // -----------------------------
    function saveSession() {
      sessionStorage.setItem(SS.titleId, $("titleId").value.trim());
      sessionStorage.setItem(SS.avaturnSubdomain, $("avaturnSubdomain").value.trim());
      sessionStorage.setItem(SS.sessionTicket, sessionTicket || "");
      sessionStorage.setItem(SS.entityToken, entityToken || "");
      sessionStorage.setItem(SS.entity, entity ? JSON.stringify(entity) : "");
    }

    function loadSession() {
      const t = sessionStorage.getItem(SS.titleId);
      const a = sessionStorage.getItem(SS.avaturnSubdomain);
      if (t) $("titleId").value = t;
      if (a) $("avaturnSubdomain").value = a;

      sessionTicket = sessionStorage.getItem(SS.sessionTicket) || null;
      entityToken = sessionStorage.getItem(SS.entityToken) || null;
      const e = sessionStorage.getItem(SS.entity);
      entity = e ? JSON.parse(e) : null;
    }

    function clearSession() {
      sessionStorage.removeItem(SS.titleId);
      sessionStorage.removeItem(SS.avaturnSubdomain);
      sessionStorage.removeItem(SS.sessionTicket);
      sessionStorage.removeItem(SS.entityToken);
      sessionStorage.removeItem(SS.entity);
      sessionTicket = null;
      entityToken = null;
      entity = null;
      avaturnModelUrl = null;
      recordedAudioBlob = null;
    }

    // -----------------------------
    // Login + EntityToken
    // -----------------------------
    async function loginUsernamePassword() {
      const titleId = getTitleId();
      const username = $("username").value.trim();
      const password = $("password").value;

      if (!username || !password) throw new Error("Enter username and password");

      setText("loginStatus", "Logging in...", "muted");
      log("Logging in...");

      const loginData = await playfabPost(titleId, "Client/LoginWithPlayFab", {
        Username: username,
        Password: password,
        TitleId: titleId
      });

      sessionTicket = loginData.SessionTicket;
      log("Login OK. SessionTicket acquired.", "ok");

      const entData = await playfabPost(
        titleId,
        "Authentication/GetEntityToken",
        {},
        { "X-Authorization": sessionTicket }
      );

      entityToken = entData.EntityToken;
      entity = entData.Entity;
      log(`EntityToken OK. Entity: ${entity.Type} / ${entity.Id}`, "ok");

      saveSession();

      setText("loginStatus", "Logged in ✅", "ok");
      show("avaturnBox");
      show("audioBox");
      show("submitBox");

      await initAvaturn();
    }

    // -----------------------------
    // Avaturn integration
    // -----------------------------
    let avaturnSdk = null;
    async function initAvaturn() {
      const subdomain = $("avaturnSubdomain").value.trim();
      if (!subdomain) throw new Error("Avaturn subdomain missing");

      const container = $("avaturn-sdk-container");
      container.innerHTML = "";

      const url = `https://${subdomain}.avaturn.dev`;
      log(`Initializing Avaturn: ${url}`);

      avaturnSdk = new AvaturnSDK();
      await avaturnSdk.init(container, { url });

      $("avaturnPill").textContent = "Waiting for export…";
      $("avaturnStatus").textContent = "Create avatar, then click Next/Export.";

      avaturnSdk.on("export", (data) => {
        const candidate =
          data?.url ||
          data?.modelUrl ||
          data?.model ||
          data?.avatar?.url ||
          data?.avatar?.modelUrl ||
          data?.exports?.[0]?.url ||
          data?.exports?.[0]?.modelUrl ||
          null;

        if (!candidate) {
          $("avaturnPill").textContent = "Export received (check console)";
          $("avaturnStatus").textContent =
            "Export callback received but no URL was auto-detected. Open console and tell me the field names.";
          log("Avaturn export received but model URL not found. Check console.", "bad");
          return;
        }

        avaturnModelUrl = candidate;
        $("avaturnPill").textContent = "Avatar exported ✅";
        $("avaturnStatus").textContent = `Captured model URL.`;
        log(`Avaturn URL captured: ${avaturnModelUrl}`, "ok");
      });
    }

    // -----------------------------
    // Audio recording to WAV (exact 5 seconds) — no ffmpeg needed
    // -----------------------------
    let audioCtx = null;
    let mediaStream = null;
    let sourceNode = null;
    let processorNode = null;
    let wavSamples = [];
    let wavSampleRate = 24000;
    let wavTimer = null;
    let isWavRecording = false;

    function floatTo16BitPCM(float32Array) {
      const out = new Int16Array(float32Array.length);
      for (let i = 0; i < float32Array.length; i++) {
        let s = Math.max(-1, Math.min(1, float32Array[i]));
        out[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
      }
      return out;
    }

    function writeWavHeader(view, sampleRate, numSamples, numChannels = 1, bitsPerSample = 16) {
      const blockAlign = numChannels * bitsPerSample / 8;
      const byteRate = sampleRate * blockAlign;
      const dataSize = numSamples * blockAlign;

      function writeStr(offset, str) {
        for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
      }

      writeStr(0, "RIFF");
      view.setUint32(4, 36 + dataSize, true);
      writeStr(8, "WAVE");
      writeStr(12, "fmt ");
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, byteRate, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, bitsPerSample, true);
      writeStr(36, "data");
      view.setUint32(40, dataSize, true);
    }

    function encodeWavFromFloatChunks(chunks, sampleRate) {
      let totalLength = 0;
      for (const c of chunks) totalLength += c.length;

      const merged = new Float32Array(totalLength);
      let offset = 0;
      for (const c of chunks) { merged.set(c, offset); offset += c.length; }

      const pcm16 = floatTo16BitPCM(merged);
      const buffer = new ArrayBuffer(44 + pcm16.byteLength);
      const view = new DataView(buffer);

      writeWavHeader(view, sampleRate, pcm16.length, 1, 16);

      let pos = 44;
      for (let i = 0; i < pcm16.length; i++, pos += 2) {
        view.setInt16(pos, pcm16[i], true);
      }

      return new Blob([buffer], { type: "audio/wav" });
    }

    async function startRecording5s() {
      recordedAudioBlob = null;
      $("audioPreview").classList.add("hidden");
      $("audioPreview").src = "";

      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      wavSampleRate = audioCtx.sampleRate;

      sourceNode = audioCtx.createMediaStreamSource(mediaStream);

      processorNode = audioCtx.createScriptProcessor(4096, 1, 1);
      wavSamples = [];
      isWavRecording = true;

      processorNode.onaudioprocess = (e) => {
        if (!isWavRecording) return;
        const input = e.inputBuffer.getChannelData(0);
        wavSamples.push(new Float32Array(input));
      };

      sourceNode.connect(processorNode);
      processorNode.connect(audioCtx.destination);

      setText("recStatus", "Recording WAV… auto-stops at 5s", "muted");
      log(`Recording WAV at ${wavSampleRate} Hz`, "info");

      $("btnRec").disabled = true;
      $("btnStop").disabled = false;

      wavTimer = setTimeout(() => stopRecording(), 5000);
    }

    async function stopRecording() {
      try {
        if (wavTimer) clearTimeout(wavTimer);
        wavTimer = null;

        if (!isWavRecording) return;
        isWavRecording = false;

        if (processorNode) processorNode.disconnect();
        if (sourceNode) sourceNode.disconnect();
        if (mediaStream) mediaStream.getTracks().forEach(t => t.stop());
        if (audioCtx) await audioCtx.close().catch(() => {});
      } finally {
        $("btnRec").disabled = false;
        $("btnStop").disabled = true;
      }

      const wavBlob = encodeWavFromFloatChunks(wavSamples, wavSampleRate);
      recordedAudioBlob = wavBlob;

      const url = URL.createObjectURL(wavBlob);
      $("audioPreview").src = url;
      $("audioPreview").classList.remove("hidden");

      setText("recStatus", `Recorded WAV ✅ (${wavBlob.size} bytes)`, "ok");
      log(`Recorded audio: ${wavBlob.type}, ${wavBlob.size} bytes`, "ok");

      wavSamples = [];
    }

    // -----------------------------
    // 1 reel per user: store the reel item id in UserData
    // -----------------------------
    async function getPrimaryReelItemId(titleId) {
      const data = await playfabPost(
        titleId,
        "Client/GetUserData",
        { Keys: [PRIMARY_REEL_KEY] },
        { "X-Authorization": sessionTicket }
      );
      return data?.Data?.[PRIMARY_REEL_KEY]?.Value || null;
    }

    async function setPrimaryReelItemId(titleId, itemId) {
      await playfabPost(
        titleId,
        "Client/UpdateUserData",
        { Data: { [PRIMARY_REEL_KEY]: itemId } },
        { "X-Authorization": sessionTicket }
      );
    }

    // -----------------------------
    // Create/Update UGC item + metadata
    // -----------------------------
    async function uploadVoiceAndUpsertReel() {
      const titleId = getTitleId();
      const itemTitle = $("itemTitle").value.trim() || "Spotlight Reel";
      const animIndex = $("animIndex").value;

      if (!sessionTicket || !entityToken) throw new Error("Not logged in");
      if (!avaturnModelUrl) throw new Error("Export avatar in Avaturn first");
      if (!recordedAudioBlob) throw new Error("Record 5s audio first");

      if (recordedAudioBlob.size > 5_000_000) {
        throw new Error("Audio too large. Please record again.");
      }

      setText("submitStatus", "Checking existing reel…", "muted");
      log("Checking PrimaryReelItemId...");

      let existingItemId = await getPrimaryReelItemId(titleId);
      log(existingItemId ? `Found PrimaryReelItemId: ${existingItemId}` : "No reel yet. Will create.", "ok");

      const voiceName = `voice_${Date.now()}.wav`;

      setText("submitStatus", "Creating upload URL…", "muted");
      log("Catalog/CreateUploadUrls (voice only) ...");

      const upData = await playfabPost(
        titleId,
        "Catalog/CreateUploadUrls",
        { Files: [{ FileName: voiceName, FileSize: recordedAudioBlob.size }] },
        { "X-EntityToken": entityToken }
      );

      const voiceUp = upData?.UploadUrls?.[0];
      if (!voiceUp?.Url || !voiceUp?.Id) throw new Error("CreateUploadUrls returned unexpected data");

      setText("submitStatus", "Uploading voice…", "muted");
      log(`Uploading voice: ${voiceName} (${recordedAudioBlob.size} bytes)`);
      await putToAzureBlob(voiceUp.Url, recordedAudioBlob);
      log("Voice upload OK.", "ok");

      const voiceUrlBase = voiceUp.Url.split("?")[0];

      const displayProps = {
        avaturnModelUrl,
        animationIndex: String(animIndex),
        upvote: 0,
        downvote: 0,
        backers: 0,
        updatedAt: new Date().toISOString()
      };

      setText("submitStatus", existingItemId ? "Updating reel item…" : "Creating reel item…", "muted");
      log("Catalog/CreateDraftItem (Publish=true) ...");

      const created = await playfabPost(
        titleId,
        "Catalog/CreateDraftItem",
        {
          Item: {
            Id: existingItemId || undefined,
            Type: "ugc",
            Title: { NEUTRAL: itemTitle },
            Description: { NEUTRAL: "Spotlight reel (voice + avaturn url)" },
            IsHidden: false,
            DisplayProperties: displayProps,
            Contents: [
              { Id: voiceUp.Id, Url: voiceUrlBase }
            ]
          },
          Publish: true,
          AllowOverwrite: !!existingItemId
        },
        { "X-EntityToken": entityToken }
      );

      const itemId = created?.Item?.Id || existingItemId;
      if (!itemId) throw new Error("CreateDraftItem succeeded but no Item.Id returned");

      if (!existingItemId) {
        await setPrimaryReelItemId(titleId, itemId);
        log(`Saved ${PRIMARY_REEL_KEY} = ${itemId}`, "ok");
      }

      setText("submitStatus", `Done ✅ ItemId: ${itemId}`, "ok");
      log(`Reel saved & published. ItemId: ${itemId}`, "ok");
    }

    // -----------------------------
    // Wire UI
    // -----------------------------
    $("btnUseDefaults").addEventListener("click", () => {
      $("titleId").value = DEFAULTS.PLAYFAB_TITLE_ID;
      $("avaturnSubdomain").value = DEFAULTS.AVATURN_SUBDOMAIN;
      setText("cfgStatus", "Defaults filled.", "muted");
      saveSession();
    });

    $("btnClearSession").addEventListener("click", () => {
      clearSession();
      setText("cfgStatus", "Session cleared. Refresh page.", "muted");
      setText("loginStatus", "", "muted");
      hide("avaturnBox"); hide("audioBox"); hide("submitBox");
      log("Session cleared.", "ok");
    });

    $("btnLogin").addEventListener("click", async () => {
      try {
        await loginUsernamePassword();
      } catch (e) {
        console.error(e);
        setText("loginStatus", e.message, "bad");
        log(e.message, "bad");
      }
    });

    $("btnRec").addEventListener("click", async () => {
      try {
        await startRecording5s();
      } catch (e) {
        console.error(e);
        setText("recStatus", e.message, "bad");
        log(`Recording failed: ${e.message}`, "bad");
        $("btnRec").disabled = false;
        $("btnStop").disabled = true;
      }
    });

    $("btnStop").addEventListener("click", () => stopRecording());

    $("btnSubmit").addEventListener("click", async () => {
      try {
        setText("submitStatus", "Working…", "muted");
        await uploadVoiceAndUpsertReel();
      } catch (e) {
        console.error(e);
        setText("submitStatus", e.message, "bad");
        log(e.message, "bad");
      }
    });

    // -----------------------------
    // Auto-restore session if present
    // -----------------------------
    (function boot() {
      loadSession();

      if (!$("titleId").value.trim()) $("titleId").value = DEFAULTS.PLAYFAB_TITLE_ID;
      if (!$("avaturnSubdomain").value.trim()) $("avaturnSubdomain").value = DEFAULTS.AVATURN_SUBDOMAIN;

      if (sessionTicket && entityToken && entity) {
        setText("loginStatus", "Session restored ✅", "ok");
        show("avaturnBox");
        show("audioBox");
        show("submitBox");
        log(`Session restored. Entity: ${entity.Type} / ${entity.Id}`, "ok");

        initAvaturn().catch(err => {
          log(`Avaturn init failed: ${err.message}`, "bad");
          $("avaturnStatus").textContent = err.message;
        });
      } else {
        log("Ready. Login to begin.");
      }
    })();
  </script>
</body>
</html>
